import argparse             # Console arguments library
import os
import glob                 # pathnames pattern matching library
import xml.etree.ElementTree as ET  #library like "Beautiful Soup Parser" but for XML

#---------------- Prepare the command line -----------------------------
def get_input_args():
    # Create Parse using ArgumentParser
    parser = argparse.ArgumentParser(description="yolo_bounding_boxs .xlm annotations into .txt files that conform to yolo format.")

    parser.add_argument("--input", type = str, default="..\\Face Mask Dataset\\annotations\\",
                    help='The Path for the input folder which contains the .png images with their corresponding .txt annotations.\n (default=..\Face Mask Dataset\annotations)')

    parser.add_argument("--output", type = str, default="..\\Face Mask Dataset\\images\\",
                    help="The path for the output folder in which .txt annotations will be saved.")


    return parser.parse_args()

#----------------------- CHECK FOR ARGUMENT ERRORS ---------------------
def check_arguments_errors(args):
    if not os.path.exists(args.input):
        raise(ValueError(f"Invalid input folder path: {os.path.abspath(args.input)}"))
    if not os.path.exists(args.output):
        raise(ValueError(f"Invalid output folder path: {os.path.abspath(args.output)}"))



#---------------- YOLO_BOUNDING_BOX CONVERTER --------------------------
def yolo_bounding_box(image_size, bounding_box):
    """Convert xml annotation to darknet format coordinates
        
       Takes as input:  (width, height) of an image
                        (xmin, ymin, xmax, ymax) of the bounding box
       and returns (x, y, w, h) of the bounding box in yolo format.
    """
    
    image_width  = 1.0 / image_size[0]
    image_height = 1.0 / image_size[1]
    
    x = (bounding_box[2] + bounding_box[0]) / 2.0
    y = (bounding_box[3] + bounding_box[1]) / 2.0
    w = abs(bounding_box[2] - bounding_box[0])
    h = abs(bounding_box[3] - bounding_box[1])
    
    x = x * image_width
    w = w * image_width

    y = y * image_height
    h = h * image_height

    return (x, y, w, h)

#---------------- XML_TO_TXT PARSER --------------------------
def xml_to_txt(input_path, output_path):
    """ Iterates through all .xml files (generated by labelImg) in the given directory,
        and generates .txt files that comply with yolo format for each .xml file.
    """

    # Class Will be used to train the model, which already exists in the XML file format.
    class_mapping = {'with_mask' : '0',
                     'without_mask' : '1',
                     'mask_weared_incorrect' : '2'}

    # Check for the existence of a folder with .xml files in it.
    if not glob.glob(input_path + '/*.xml'):
        raise(ValueError(f"Empty folder, there are no .xml files in {input_path}."))

    # Loop through the .xml files to convert them.
    for xml_file in glob.glob(input_path + '/*.xml'):

        tree = ET.parse(xml_file)   #File of "dictionary-like" tree structure format to extract information. 
        root = tree.getroot()       #Handler

        # Start capturing the objects intended values in a list to save them later in a .txt file. 
        txt_list = []

        # Loop through objects within the current file.
        for face_object in root.findall("object"):   #object (in an object detection problem) means the faces in the image.

            # File name to be used to build the .txt version.
            file_name = root.find("filename").text # (i.e. maksssksksss0.png)
            
            # The whole image dimensions.
            image_width  = int(root.find('size')[0].text) #(i.e. 512)
            image_height = int(root.find("size")[1].text) #(i.e. 366)
            image_size = (image_width, image_height)

            # The class of the object
            object_class = face_object[0].text #(i.e. without_mask)
            
            # face_object[5] is the "TAG: <bndbox>" in which contains <xmin>, <ymin>, <xmax>, <ymax>
            # values respectively. (i.e. (79.0, 105.0, 109.0, 142.0))
            bounding_box = (float(face_object[5][0].text),  #<xmin>
                            float(face_object[5][1].text),  #<ymin>
                            float(face_object[5][2].text),  #<xmax>
                            float(face_object[5][3].text))  #<ymax>

            # bounding box conversion to YOLO Format.
            bounding_box_yolo = yolo_bounding_box(image_size, bounding_box)                     
            
            # Store the objects information in the list txt_list to be written in a .txt file later.
            txt_list.append(class_mapping.get(object_class) + " " + " ".join([str(cord) for cord in bounding_box_yolo]) + "\n")
            # i.e. ['1 0.18359375 0.337431693989071 0.05859375 0.10109289617486339\n']
            #        <class_name> <x_center> <y_center> <width> <height>
            #        1(Class)     followed by the bounding box values in yolo format
            # Note that we will keep appending values will the loop in running.

        # Writing the captured values in a .txt file in a specified output path.
        with open(output_path + "/" + file_name.split(".")[0] + ".txt", "w") as writer:
            for obj in txt_list:
                writer.write(obj)


def main():
    args = get_input_args()
    check_arguments_errors(args)   

    xml_to_txt(args.input, args.output)
         
if __name__ == "__main__":
    main()